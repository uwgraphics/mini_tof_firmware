#include "example12.h"
#include <cstdio>
#include <ratio>

extern DigitalOut led;
extern DigitalOut test;
extern DigitalOut test2;

// #define Human_readable_mode
#define Binary_mode

extern BufferedSerial pc;

// Global variables
uint8_t status, loop, isAlive, isReady, i;
VL53LMZ_ResultsData Results;                    // Results data from VL53LMZ
VL53LMZ_Motion_Configuration cnh_config;        // Motion Configuration is shared with CNH

cnh_data_buffer_t cnh_data_buffer;              // cnh_data_bufer_t is sized to take the largest data transfer
											   // possible from the device. If smaller CNH configuration is
											   // used then cnh_data_buffer size could be make smaller.

uint32_t cnh_data_size;                        // This will be used to record the actual size of CNH data
											   // generated by the set CNH configuration.

int agg_id, bin_num;
float amb_value, bin_value;

VL53LMZ_Configuration *Dev;

int32_t *p_hist = NULL;
int8_t *p_hist_scaler = NULL;
int32_t *p_ambient = NULL;
int8_t *p_ambient_scaler = NULL;

int NUMBINS = 17; // Number of bins in the CNH configuration
int NUMAGGREGATES = 3; // Number of aggregates in the CNH configuration

// Forward declaration
int the_ranging_part();

int example12(VL53LMZ_Configuration *p_dev)
{
	// Store sensor configuration
	Dev = p_dev;
	Reset_Sensor(&(Dev->platform));
	
	// Power on sensor and initialize
	printf("is_alive\r\n");
	status = vl53lmz_is_alive(Dev, &isAlive);
	if (!isAlive || status) {
		printf("VL53LMZ not detected at requested address\r\n");
		return status;
	}
	printf("is_alive successful\r\n");

	// Initialize the VL53LMZ sensor
	printf("init\r\n");
	status = vl53lmz_init(Dev);
	printf("status = %u\r\n", status);
	if (status) {
		printf("VL53LMZ ULD Loading failed\r\n");
		return status;
	}
	printf("VL53LMZ ULD ready ! (Version : %s)\r\n", VL53LMZ_API_REVISION);

	// Set basic ranging settings
	status = vl53lmz_set_resolution(Dev, 64);
	printf("set_resolution status: %u\r\n", status);
	
	status |= vl53lmz_set_ranging_mode(Dev, VL53LMZ_RANGING_MODE_AUTONOMOUS);
	printf("set_ranging status: %u\r\n", status);
	
	status |= vl53lmz_set_ranging_frequency_hz(Dev, 30);
	printf("set_ranging frequency status: %u\r\n", status);
	
	status |= vl53lmz_set_integration_time_ms(Dev, 20);
	printf("set_integration status: %u\r\n", status);
	
	if (status) {
		printf("ERROR - Failed basic configuration sequence, status=%u\r\n", status);
		return status;
	}

	// CNH specific configuration
	// Populate the basic CNH parameters into the CNH configuration structure
	status = vl53lmz_cnh_init_config(&cnh_config,
									 0,    // StartBin
									 NUMBINS,   // NumBins
									 1);   // SubSample
	if (status != VL53LMZ_STATUS_OK) {
		printf("ERROR at %s(%d) : vl53lmz_cnh_init_config failed : %d\r\n", __func__, __LINE__, status);
		return status;
	}

	// Add the aggregate map that maps zones to aggregates
	// Resolution of map must follow that set by vl53lmz_set_resolution(), either 16 or 64 zones
	status = vl53lmz_cnh_create_agg_map(&cnh_config,
									   64,   // Resolution. Must match value used in vl53lmz_set_resolution()
									   0,    // StartX
									   0,    // StartY
									   1,    // MergeX
									   1,    // MergeY
									   8,    // Cols
									   8);   // Rows
	if (status != VL53LMZ_STATUS_OK) {
		printf("ERROR at %s(%d) : vl53lmz_cnh_create_agg_map failed : %d\r\n", __func__, __LINE__, status);
		return status;
	}

	// Check that the requested configuration will not generate CNH data that is too large
	// Store the size of data generate so we can next setup an optimize data transfer from sensor to host
	status = vl53lmz_cnh_calc_required_memory(&cnh_config, &cnh_data_size);
	if (status != VL53LMZ_STATUS_OK) {
		printf("ERROR at %s(%d) : vl53lmz_cnh_calc_required_memory : %d\r\n", __func__, __LINE__, status);
		if (cnh_data_size < 0) {
			printf("Required memory is too high : %lu. Maximum is %lu!\r\n", cnh_data_size, VL53LMZ_CNH_MAX_DATA_BYTES);
		}
		return status;
	}

	// Send this CNH configuration to the sensor
	status = vl53lmz_cnh_send_config(Dev, &cnh_config);
	if (status != VL53LMZ_STATUS_OK) {
		printf("ERROR at %s(%d) : vl53lmz_cnh_send_config failed : %d\r\n", __func__, __LINE__, status);
		return status;
	}

	// First create the standard data upload(output) configuration
	status = vl53lmz_create_output_config(Dev);
	if (status != VL53LMZ_STATUS_OK) {
		printf("ERROR at %s(%d) : vl53lmz_create_output_config failed : %d\r\n", __func__, __LINE__, status);
		return status;
	}

	// Add the CNH data block, sized correctly for the configuration we are using
	union Block_header cnh_data_bh;
	cnh_data_bh.idx = VL53LMZ_CNH_DATA_IDX;
	cnh_data_bh.type = 4;
	cnh_data_bh.size = cnh_data_size / 4;
	status = vl53lmz_add_output_block(Dev, cnh_data_bh.bytes);
	if (status != VL53LMZ_STATUS_OK) {
		printf("ERROR at %s(%d) : vl53lmz_add_output_block failed : %d\r\n", __func__, __LINE__, status);
		return status;
	}

	// Start the sensor ranging
	// Send the output configuration and start the sensor ranging
	status = vl53lmz_send_output_config_and_start(Dev);
	printf("send_output_config_and_start status : %u\r\n", status);
	
	the_ranging_part();
	return status;
}

int swap_config(int aggregate_num) {
	// Calculate the start bin for the given configuration index
	int startBin = aggregate_num * NUMBINS;
	
	// Update bin configuration
	status = vl53lmz_cnh_init_config(&cnh_config,
									startBin,    // StartBin based on current config index
									NUMBINS,     // NumBins
									1);          // SubSample
	if (status != VL53LMZ_STATUS_OK) {
		printf("ERROR: vl53lmz_cnh_init_config failed: %d\r\n", status);
		return status;
	}
	
	// Send new configuration to the sensor
	status = vl53lmz_cnh_send_config(Dev, &cnh_config);
	if (status != VL53LMZ_STATUS_OK) {
		printf("ERROR: vl53lmz_cnh_send_config failed: %d\r\n", status);
		return status;
	}
	
	return status;
}

int the_ranging_part()
{
    size_t scan_count = 0;
    size_t input = 0;
    char the_temp_byte_array[4];
    float temp_agg_id = 0;
    int aggregate_num = 0;  // Toggle between bin configs (0 or 64)
    int readings_since_swap = 0;  // Track readings since last config swap

    while (1)
    {
        uint8_t isReady = 0;
        uint32_t start1 = us_ticker_read();
        status = vl53lmz_check_data_ready(Dev, &isReady);
        test = isReady;
        
        if (isReady)
        {
			// need to read at least 3 times for data to be in phase
            if (readings_since_swap >= 3) {
				aggregate_num = ++aggregate_num % NUMAGGREGATES;
                status = swap_config(aggregate_num);
                if (status != VL53LMZ_STATUS_OK) {
                    printf("ERROR: Failed to swap configuration: %d\r\n", status);
                    return status;
                }
                temp_agg_id = 0;
                readings_since_swap = 0;  // Reset counter after swap
            }
            
            test2 = 0;
            uint32_t start2 = us_ticker_read();
            vl53lmz_get_ranging_data(Dev, &Results);
            test2 = 1;
            uint32_t start3 = us_ticker_read();

            // Extract CNH data from the ULD transfer buffer
            status = vl53lmz_results_extract_block(Dev, VL53LMZ_CNH_DATA_IDX,
                                               (uint8_t *)cnh_data_buffer, cnh_data_size);
            if (status != VL53LMZ_STATUS_OK)
            {
                printf("ERROR at %s(%d) : vl53lmz_results_extract_block failed : %d\r\n",
                       __func__, __LINE__, status);
                return status;
            }

            // Process each aggregate
            for (agg_id = 0; agg_id < cnh_config.nb_of_aggregates; agg_id++)
            {
                // Get addresses of data blocks for this aggregate
                vl53lmz_cnh_get_block_addresses(&cnh_config, agg_id,
                                              cnh_data_buffer, &(p_hist), &(p_hist_scaler),
                                              &(p_ambient), &(p_ambient_scaler));

                // Get ambient value for this aggregate
                amb_value = ((float)*p_ambient) / (2 << *p_ambient_scaler);

#ifdef Human_readable_mode
                printf("Agg, %2d, Ambient, %.2f, Bins, ", agg_id, amb_value);
#endif

#ifdef Binary_mode
                memcpy(the_temp_byte_array, &temp_agg_id, 4);
                temp_agg_id++;
                pc.write(the_temp_byte_array, 4);
                memcpy(the_temp_byte_array, &amb_value, 4);
                pc.write(the_temp_byte_array, 4);
#endif

                // Process each bin in the aggregate
                for (bin_num = 0; bin_num < cnh_config.feature_length; bin_num++)
                {
                    bin_value = ((float)p_hist[bin_num]) / (2 << p_hist_scaler[bin_num]);

#ifdef Binary_mode
                    memcpy(the_temp_byte_array, &bin_value, 4);
                    pc.write(the_temp_byte_array, 4);
#endif

#ifdef Human_readable_mode
                    printf("%.1f, ", bin_value);
#endif
                }

#ifdef Human_readable_mode
                printf("\n\r");
#endif

#ifdef Binary_mode
                char binary123[4] = {0xff, 0xff, 0xff, 0xff};
                pc.write(binary123, 4);
#endif
            }

#ifdef Binary_mode
			// Process proprietary distances
			for (agg_id = 0; agg_id < cnh_config.nb_of_aggregates; agg_id++)
			{
				float distance = Results.distance_mm[VL53LMZ_NB_TARGET_PER_ZONE*agg_id];

				memcpy(the_temp_byte_array, &distance, 4);
				pc.write(the_temp_byte_array, 4);

			}

			// Write the current readings_since_swap value first
			float current_reading_count = readings_since_swap;
			memcpy(the_temp_byte_array, &current_reading_count, 4);
			pc.write(the_temp_byte_array, 4);
			
			// Write the current startBin value
			float current_start_bin = aggregate_num * NUMBINS;
			memcpy(the_temp_byte_array, &current_start_bin, 4);
			pc.write(the_temp_byte_array, 4);

			char binary123[4] = {0xff, 0xff, 0xff, 0xff};
			pc.write(binary123, 4);
#endif
            
            uint32_t end = us_ticker_read();

#if defined(Human_readable_mode) || defined(debugging_mode)
            printf("\n\n\n\n\n\n\n\n\n\n\n");
            printf("%i %i %i \n\r", start2 - start1, start3 - start2, end - start3);
            printf("\033[100A"); // Move up 100 lines
#endif
            
            // Increment the readings counter after successful processing
            readings_since_swap++;
        }

        // Reset aggregate ID counter for next iteration
        temp_agg_id = 0;
    }

    status = vl53lmz_stop_ranging(Dev);
    printf("Stop ranging autonomous\n");

    return status;
}
